class LocationParser(): 
    def __init__(self, file_location, field_width_meters, field_height_meters, field_width_pixels, field_height_pixels, debug_print=False):
        """LOCATION PARSER, if you're creating new games copy this entire class and the two lines directly after it
            you need to indicate the location of the file that is generated by the ROS system. This class will map that position to the 
            pixel coordinates and give you a list of the read points

        Args:
            file_location (string): Location of the lidar_output.txt, which is generated by the makers_people_detect package in the ros workspace
            field_width_meters (float): the width of the field read by the lidar through ROS, this can be found by looking in PolyGen or by viewing it in RVIZ
            field_height_meters (float): height of the field read by the lidar through ROS
            field_width_pixels (int): resolution width of the output game 
            field_height_pixels (int): resolution height of the output game 
            debug_print (bool): prints parsed information to the terminal for debugging when True
        """
        self.file_location = file_location #location of lidar_output.txt generated by the ROS system

        self.debug_print = debug_print

        #size of the polygon that is displayed in rviz
        self.field_width_meters = field_width_meters
        self.field_height_meters = field_height_meters

        #resolution of the game
        self.field_width_pixels = field_width_pixels
        self.field_height_pixels = field_height_pixels

    def getPositions(self): 
        """Reads the lidar_output.txt file and parses the file contents into an array of positions 

        Returns:
            List (Tuple (float)): positions contained in the lidar_output.txt file generated by the ROS lidar system.
        """

        #open the file in read mode
        with open(self.file_location, 'r') as f:

            #read file as string
            position_string = f.read()

            #list of positions that we will be returning 
            position_list = []

            #split the read in string by line, this gives us one string per line of text generated by the ROS system
            xy_position_lines= position_string.split('\n')

            #loop through each line of text
            for a in xy_position_lines: 

                #now we do the conversion from string to float
                #the conversion is read_value * output_unit/input_unit 
                #the ros system publishes locations in meters, based on the field size we can map it to a position with this. 
                try:
                    position = (float(a.split(',')[1]) * self.field_width_pixels/self.field_width_meters, float(a.split(',')[0]) * self.field_height_pixels/self.field_height_meters)        

                    #if we were able to parse the point, add it to the list
                    position_list.append(position)
                except IndexError: 
                    if(self.debug_print):
                        print("Failed to parse position from \'%s\'" % a)
                    else:
                        pass
            
            #terminal spam, can be commented out
            if(self.debug_print):
                print(position_list)
           
            # return positions
            return position_list